{"version":3,"file":"VaIcon.mjs","sources":["../../../../node_modules/lodash/_arrayMap.js","../../../../node_modules/lodash/_isKey.js","../../../../node_modules/lodash/memoize.js","../../../../node_modules/lodash/_memoizeCapped.js","../../../../node_modules/lodash/_stringToPath.js","../../../../node_modules/lodash/_baseToString.js","../../../../node_modules/lodash/toString.js","../../../../node_modules/lodash/_castPath.js","../../../../node_modules/lodash/_toKey.js","../../../../node_modules/lodash/_baseGet.js","../../../../node_modules/lodash/_baseSlice.js","../../../../node_modules/lodash/_parent.js","../../../../node_modules/lodash/_baseUnset.js","../../../../node_modules/lodash/last.js","../../../../node_modules/lodash/_customOmitClone.js","../../../../node_modules/lodash/_flatRest.js","../../../../node_modules/lodash/omit.js","../../src/services/icon-config/utils/regex.ts","../../src/services/icon-config/utils/dynamic-segment.ts","../../src/services/icon-config/types.ts","../../src/services/icon-config/icon-helpers.ts","../../src/services/icon-config/icon-config-hooks.ts","../../src/components/va-icon/VaIcon.vue","../../src/components/va-icon/VaIcon.vue?vue&type=template&id=28d73628&lang.js"],"sourcesContent":["/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n","var baseGet = require('./_baseGet'),\n    baseSlice = require('./_baseSlice');\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nmodule.exports = parent;\n","var castPath = require('./_castPath'),\n    last = require('./last'),\n    parent = require('./_parent'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = castPath(path, object);\n  object = parent(object, path);\n  return object == null || delete object[toKey(last(path))];\n}\n\nmodule.exports = baseUnset;\n","/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n","var isPlainObject = require('./isPlainObject');\n\n/**\n * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n * objects.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} key The key of the property to inspect.\n * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n */\nfunction customOmitClone(value) {\n  return isPlainObject(value) ? undefined : value;\n}\n\nmodule.exports = customOmitClone;\n","var flatten = require('./flatten'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nmodule.exports = flatRest;\n","var arrayMap = require('./_arrayMap'),\n    baseClone = require('./_baseClone'),\n    baseUnset = require('./_baseUnset'),\n    castPath = require('./_castPath'),\n    copyObject = require('./_copyObject'),\n    customOmitClone = require('./_customOmitClone'),\n    flatRest = require('./_flatRest'),\n    getAllKeysIn = require('./_getAllKeysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */\nvar omit = flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = arrayMap(paths, function(path) {\n    path = castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  copyObject(object, getAllKeysIn(object), result);\n  if (isDeep) {\n    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    baseUnset(result, paths[length]);\n  }\n  return result;\n});\n\nmodule.exports = omit;\n","export const isMatchRegex = (str: string, regex: RegExp) => {\n  return regex.test(str)\n}\n\n/**\n * Return values from regex groups\n * @example\n * ```\n * \"fa-phone-o\", /fa-(.*)-(.*)/ -> [\"phone\", \"o\"]\n * \"any string\", /(.*)/ -> [\"any string\"]\n * \"global regex test\", /global (regex) (test)/g -> [['regex', 'test']]\n * ```\n */\nexport const regexGroupsValues = (str: string, regex: RegExp | string): string[] | string[][] => {\n  if (typeof regex !== 'string' && regex.global) {\n    // Global regex can return multiple matches array. So we need to map this all matches and remove non group values.\n    return [...str.matchAll(regex)].map(g => g.slice(1))\n  }\n\n  const match = str.match(regex) || []\n  if (!match) { return [] }\n  /**\n   * If there is groups in result - we need to slice first match\n   * ```\n   * \"test\".match(/(s)/)\n   * > Array [ \"s\", \"s\" ]\n   * ```\n   */\n  if (match.length > 1) { return match.slice(1) }\n\n  return match\n}\n","import { regexGroupsValues } from './regex'\n\nconst dynamicSegmentRegex = /{[^}]*}/g // match {any-thing}, {even with space}\n\n/**\n * Replace {anything} to regex (.*) group\n * @example\n * ```\n * \"fa-{code}\" -> \"fa-(.*)\"\n * \"fa-{code}-{suffix}\" -> \"fa-(.*)-(.*)\"\n * ```\n */\nconst dynamicSegmentStringToRegex = (template: string) => {\n  return template.replace(dynamicSegmentRegex, '(.*)')\n}\n\n/**\n Returns content from string in {}\n @example\n ```\n \"fa-{code}-{suffix}\" -> ['code', 'suffix']\n ```\n */\nconst dynamicSegmentsNames = (template: string) => {\n  return (template.match(dynamicSegmentRegex) || []) // 'fa-{code}-{suffix}' -> ['{code}', '{suffix}']\n    .map((g) => g.replace(/{|}/g, '')) // ['{code}', '{suffix}'] -> ['code', 'suffix']\n}\n\n/**\n * Transform template to regex and returns regex group values\n * @example\n * ```\n * \"fa-clock-o\", \"fa-{code}-{suffix}\" -> [\"clock\", \"o\"]\n * ```\n */\nconst dynamicSegmentsValues = (str: string, template: string) => {\n  return regexGroupsValues(str, dynamicSegmentStringToRegex(template))\n}\n\n/**\n * Returns object with param name from template and match value from str\n * @example\n * ```\n * \"fa-phone\", \"fa-{icon code}\" -> { 'icon code': 'phone' }\n * \"fa4 clock-o\", \"fa4 {icon-code}-{suffix}\" -> { 'icon-code': 'clock', 'suffix': 'o' }\n * \"fa4 clock-o\", \"fa4 {icon-code}\" -> { 'icon-code': 'clock-o' }\n * ```\n */\nexport const dynamicSegments = (str: string, template: string) => {\n  const params = dynamicSegmentsNames(template)\n  const values = dynamicSegmentsValues(str, template)\n\n  return params.reduce((acc, paramValue, i) => ({ ...acc, [paramValue]: values[i] }), {})\n}\n\n/**\n * Returns true if match string equals to input `str`\n * @example\n * ```\n * \"vuestic-home-open\", /vuestic-(.*)-o/ -> false\n * \"vuestic-home-open\", /vuestic-(.*)-open/ -> true\n * ```\n */\nconst strictMatch = (str: string, regex: RegExp) => {\n  return (str.match(regex) || [])[0] === str\n}\n\n/**\n * Returns true if str match template\n * @example\n *  ```\n * \"fa-phone\", \"fa-{icon code}\" -> true\n * \"fa4 clock-o\", \"fa4 {icon-code}-{suffix}\" -> true\n * \"fa4 clock-o\", \"fa4 {icon-code}\" -> false\n * ```\n */\nexport const isMatchDynamicSegments = (str: string, template: string) => {\n  const templateRegex = dynamicSegmentStringToRegex(template)\n  return strictMatch(str, new RegExp(templateRegex))\n}\n","export interface IconProps {\n  attrs?: Record<string, string | ((...args: any[]) => unknown)>\n\n  /** Vue component */\n  component?: any\n  /** Content that will be passed as text inside icon tag or as slot in component */\n  content?: string\n\n  class?: string,\n  tag?: string\n  color?: string\n  rotation?: number | string\n  spin?: 'clockwise' | 'counter-clockwise' | boolean\n  to?: string\n}\n\nexport interface IconConfigurationString extends IconProps {\n  name: string\n  resolve?: ((dynamicSegments: {[dynamicSegment: string]: string }) => IconProps)\n}\n\nexport interface IconConfigurationRegex extends IconProps {\n  name: RegExp\n  // Need a different resolve method name because ts don't understand types\n  resolveFromRegex?: ((...regexGroupValues: string[]) => IconProps)\n}\n\nexport type IconConfiguration = IconConfigurationString | IconConfigurationRegex\n\nexport type IconConfig = IconConfiguration[]\n\nexport const isIconConfigurationString = (config: IconConfiguration): config is IconConfigurationString => {\n  return typeof config.name === 'string'\n}\n\nexport const isIconConfigurationRegex = (config: IconConfiguration): config is IconConfigurationRegex => {\n  return config.name instanceof RegExp\n}\n","import merge from 'lodash/merge.js'\nimport { getGlobalConfig } from '../global-config/global-config'\nimport { isMatchDynamicSegments, dynamicSegments } from './utils/dynamic-segment'\nimport { isMatchRegex, regexGroupsValues } from './utils/regex'\nimport {\n  IconConfig,\n  IconConfiguration,\n  IconConfigurationString,\n  IconConfigurationRegex,\n  isIconConfigurationString,\n  isIconConfigurationRegex,\n  IconProps,\n} from './types'\n\nconst getIconConfig = (): IconConfig => {\n  return getGlobalConfig().icons || []\n}\n\nconst isMatchConfiguration = (iconName: string, iconConfiguration: IconConfiguration) => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return isMatchDynamicSegments(iconName, iconConfiguration.name)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return isMatchRegex(iconName, iconConfiguration.name)\n  }\n\n  return false\n}\n\nconst resolveIconConfigurationString = (iconName: string, iconConfiguration: IconConfigurationString) => {\n  const args = dynamicSegments(iconName, iconConfiguration.name)\n  return iconConfiguration.resolve && iconConfiguration.resolve(args)\n}\n\nconst resolveIconConfigurationRegex = (iconName: string, iconConfig: IconConfigurationRegex) => {\n  if (iconConfig.name.global) {\n    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`)\n  }\n  const args = regexGroupsValues(iconName, iconConfig.name) as string[]\n  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args)\n}\n\nconst resolveIconConfiguration = (iconName: string, iconConfiguration: IconConfiguration): IconProps | undefined => {\n  if (isIconConfigurationString(iconConfiguration)) {\n    return resolveIconConfigurationString(iconName, iconConfiguration)\n  }\n  if (isIconConfigurationRegex(iconConfiguration)) {\n    return resolveIconConfigurationRegex(iconName, iconConfiguration)\n  }\n\n  throw Error('Unknown icon config')\n}\n\nconst findMatchedIconConfiguration = (iconName: string, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration => {\n  const matchedConfig = globalIconConfig.find((config) => {\n    if (namesToIgnore.includes(config.name.toString())) { return false }\n\n    return isMatchConfiguration(iconName, config)\n  })\n\n  if (!matchedConfig) { throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`) }\n\n  return matchedConfig\n}\n\nconst findIconConfiguration = (iconName: string | undefined, globalIconConfig: IconConfig, namesToIgnore: string[] = []): IconConfiguration | undefined => {\n  if (!iconName) { return }\n\n  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore)\n  const resolvedIconConfiguration = merge(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration)\n\n  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()]\n\n  return merge(\n    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),\n    resolvedIconConfiguration,\n  )\n}\n\n/** Removes name, to, resolveFromRegex and resolve from IconConfiguration */\nconst iconPropsFromIconConfiguration = (iconConfiguration: IconConfiguration): IconProps => {\n  const junkKeys = ['name', 'to', 'resolve', 'resolveFromRegex']\n\n  const configuration: Record<string, string> = iconConfiguration as any\n  junkKeys.forEach((key) => { delete configuration[key] })\n  return configuration\n}\n\nexport const getIconConfiguration = (name: string, iconConfig: IconConfig = getIconConfig()): IconProps => {\n  const configuration = findIconConfiguration(name, iconConfig)\n\n  if (configuration === undefined) { return {} }\n\n  return iconPropsFromIconConfiguration(configuration)\n}\n","import { getIconConfiguration } from './icon-helpers'\n\nexport const useIcons = (props: any) => {\n  return {\n    // TODO: export here function that can dynamically change icons config\n    getIcon: (name: string) => getIconConfiguration(name),\n  }\n}\n","<template>\n  <component\n    v-bind=\"computedAttrs\"\n    aria-hidden=\"true\"\n    notranslate\n    class=\"va-icon\"\n    :is=\"computedTag\"\n    :class=\"computedClass\"\n    :style=\"computedStyle\"\n  >\n    <slot>\n      <template v-if=\"iconConfig.content\">\n        {{ iconConfig.content }}\n      </template>\n    </slot>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, computed } from 'vue'\nimport omit from 'lodash/omit.js'\nimport { useColors } from '../../services/color-config/color-config'\nimport { useIcons } from '../../services/icon-config/icon-config'\nimport { useSize, useSizeProps } from '../../composables/useSize'\n\nexport default defineComponent({\n  name: 'VaIcon',\n  props: {\n    ...useSizeProps,\n    name: { type: String as PropType<string>, default: '' },\n    tag: { type: String as PropType<string> },\n    component: { type: Object as PropType<Record<string, any>> },\n    color: { type: String as PropType<string> },\n    rotation: { type: [String, Number] as PropType<number | string> },\n    spin: { type: [String, Boolean] as PropType<string | boolean> },\n    flip: {\n      type: String as PropType<'off' | 'horizontal' | 'vertical' | 'both'>,\n      default: 'off',\n      validator: (value: string) => ['off', 'horizontal', 'vertical', 'both'].includes(value),\n    },\n  },\n  setup (props, { attrs }) {\n    const { getColor } = useColors()\n    const { sizeComputed } = useSize(props)\n    const { getIcon } = useIcons(props)\n\n    const iconConfig = computed(() => getIcon(props.name))\n\n    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || 'i')\n\n    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit(attrs, ['class']) }))\n\n    const getSpinClass = (spin?: string | boolean) => {\n      if (spin === undefined || spin === false) { return }\n      return spin === 'counter-clockwise' ? 'va-icon--spin-reverse' : 'va-icon--spin'\n    }\n\n    const computedClass = computed(() => [\n      iconConfig.value.class,\n      getSpinClass(props.spin ?? iconConfig.value.spin),\n    ])\n\n    const transformStyle = computed(() => {\n      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : ''\n\n      const flipY = (props.flip === 'vertical' || props.flip === 'both') ? -1 : 1\n      const flipX = (props.flip === 'horizontal' || props.flip === 'both') ? -1 : 1\n      const scale = props.flip === 'off' ? '' : `scale(${flipY}, ${flipX})`\n\n      return `${scale} ${rotation}`.trim()\n    })\n\n    const computedStyle = computed(() => ({\n      transform: transformStyle.value,\n      cursor: attrs.onClick ? 'pointer' : null,\n      color: props.color ? getColor(props.color, undefined, true) : iconConfig.value.color,\n      fontSize: sizeComputed.value,\n    }))\n\n    return {\n      iconConfig,\n      computedTag,\n      computedAttrs,\n      computedClass,\n      computedStyle,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-icon {\n  vertical-align: var(--va-icon-vertical-align);\n  user-select: var(--va-icon-user-select);\n\n  &#{&} {\n    // need 2 classes to make it work\n    font-style: normal;\n  }\n\n  &--spin {\n    animation: va-icon--spin-animation 1500ms linear infinite;\n\n    &-reverse {\n      animation: va-icon--spin-animation 1500ms linear infinite;\n      animation-direction: reverse;\n    }\n  }\n\n  @keyframes va-icon--spin-animation {\n    from {\n      transform: rotate(0deg);\n    }\n\n    to {\n      transform: rotate(360deg);\n    }\n  }\n}\n</style>\n","<template>\n  <component\n    v-bind=\"computedAttrs\"\n    aria-hidden=\"true\"\n    notranslate\n    class=\"va-icon\"\n    :is=\"computedTag\"\n    :class=\"computedClass\"\n    :style=\"computedStyle\"\n  >\n    <slot>\n      <template v-if=\"iconConfig.content\">\n        {{ iconConfig.content }}\n      </template>\n    </slot>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, PropType, computed } from 'vue'\nimport omit from 'lodash/omit.js'\nimport { useColors } from '../../services/color-config/color-config'\nimport { useIcons } from '../../services/icon-config/icon-config'\nimport { useSize, useSizeProps } from '../../composables/useSize'\n\nexport default defineComponent({\n  name: 'VaIcon',\n  props: {\n    ...useSizeProps,\n    name: { type: String as PropType<string>, default: '' },\n    tag: { type: String as PropType<string> },\n    component: { type: Object as PropType<Record<string, any>> },\n    color: { type: String as PropType<string> },\n    rotation: { type: [String, Number] as PropType<number | string> },\n    spin: { type: [String, Boolean] as PropType<string | boolean> },\n    flip: {\n      type: String as PropType<'off' | 'horizontal' | 'vertical' | 'both'>,\n      default: 'off',\n      validator: (value: string) => ['off', 'horizontal', 'vertical', 'both'].includes(value),\n    },\n  },\n  setup (props, { attrs }) {\n    const { getColor } = useColors()\n    const { sizeComputed } = useSize(props)\n    const { getIcon } = useIcons(props)\n\n    const iconConfig = computed(() => getIcon(props.name))\n\n    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || 'i')\n\n    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit(attrs, ['class']) }))\n\n    const getSpinClass = (spin?: string | boolean) => {\n      if (spin === undefined || spin === false) { return }\n      return spin === 'counter-clockwise' ? 'va-icon--spin-reverse' : 'va-icon--spin'\n    }\n\n    const computedClass = computed(() => [\n      iconConfig.value.class,\n      getSpinClass(props.spin ?? iconConfig.value.spin),\n    ])\n\n    const transformStyle = computed(() => {\n      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : ''\n\n      const flipY = (props.flip === 'vertical' || props.flip === 'both') ? -1 : 1\n      const flipX = (props.flip === 'horizontal' || props.flip === 'both') ? -1 : 1\n      const scale = props.flip === 'off' ? '' : `scale(${flipY}, ${flipX})`\n\n      return `${scale} ${rotation}`.trim()\n    })\n\n    const computedStyle = computed(() => ({\n      transform: transformStyle.value,\n      cursor: attrs.onClick ? 'pointer' : null,\n      color: props.color ? getColor(props.color, undefined, true) : iconConfig.value.color,\n      fontSize: sizeComputed.value,\n    }))\n\n    return {\n      iconConfig,\n      computedTag,\n      computedAttrs,\n      computedClass,\n      computedStyle,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-icon {\n  vertical-align: var(--va-icon-vertical-align);\n  user-select: var(--va-icon-user-select);\n\n  &#{&} {\n    // need 2 classes to make it work\n    font-style: normal;\n  }\n\n  &--spin {\n    animation: va-icon--spin-animation 1500ms linear infinite;\n\n    &-reverse {\n      animation: va-icon--spin-animation 1500ms linear infinite;\n      animation-direction: reverse;\n    }\n  }\n\n  @keyframes va-icon--spin-animation {\n    from {\n      transform: rotate(0deg);\n    }\n\n    to {\n      transform: rotate(360deg);\n    }\n  }\n}\n</style>\n"],"names":["_arrayMap","arrayMap","array","iteratee","index","length","result","Array","isArray","require$$0","isSymbol","require$$1","reIsDeepProp","reIsPlainProp","_isKey","isKey","value","object","type","test","Object","MapCache","memoize","func","resolver","TypeError","memoized","args","arguments","key","apply","this","cache","has","get","set","Cache","rePropName","reEscapeChar","_stringToPath","memoizeCapped","size","clear","string","charCodeAt","push","replace","match","number","quote","subString","require$$2","require$$3","symbolProto","prototype","undefined","symbolToString","toString","baseToString","call","toString_1","stringToPath","_castPath","castPath","_toKey","toKey","_baseGet","baseGet","path","_baseSlice","baseSlice","start","end","last","parent","isPlainObject","flatten","overRest","setToString","_flatRest","flatRest","baseClone","baseUnset","copyObject","require$$4","customOmitClone","getAllKeysIn","require$$7","require$$6","paths","isDeep","CLONE_DEEP_FLAG","regexGroupsValues","str","regex","global","matchAll","map","g","slice","dynamicSegmentRegex","dynamicSegmentStringToRegex","template","dynamicSegments","params","dynamicSegmentsNames","values","dynamicSegmentsValues","reduce","acc","paramValue","i","isIconConfigurationString","config","name","isIconConfigurationRegex","RegExp","isMatchConfiguration","iconName","iconConfiguration","templateRegex","strictMatch","isMatchDynamicSegments","resolveIconConfiguration","resolve","resolveIconConfigurationString","iconConfig","Error","resolveFromRegex","resolveIconConfigurationRegex","findIconConfiguration","globalIconConfig","namesToIgnore","matchedIconConfiguration","matchedConfig","find","includes","findMatchedIconConfiguration","resolvedIconConfiguration","merge","to","getIconConfiguration","getGlobalConfig","icons","getIconConfig","configuration","forEach","iconPropsFromIconConfiguration","useIcons","props","getIcon","defineComponent","useSizeProps","String","default","tag","component","color","rotation","Number","spin","Boolean","flip","validator","setup","attrs","getColor","useColors","sizeComputed","useSize","computed","computedTag","computedAttrs","omit","getSpinClass","computedClass","class","transformStyle","flipY","flipX","trim","computedStyle","transform","cursor","onClick","fontSize","_createBlock","_ctx","_mergeProps","notranslate","style","_renderSlot","_createElementBlock","content"],"mappings":"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"}