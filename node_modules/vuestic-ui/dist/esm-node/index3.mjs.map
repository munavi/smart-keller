{"version":3,"file":"index3.mjs","sources":["../../../../node_modules/lodash/noop.js","../../../../node_modules/lodash/throttle.js","../../src/components/va-affix/VaAffix-utils.ts","../../src/components/va-affix/VaAffix.vue","../../src/components/va-affix/VaAffix.vue?vue&type=template&id=c9e05218&lang.js","../../src/components/va-affix/index.ts"],"sourcesContent":["/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","import throttle from 'lodash/throttle.js'\nimport type { VueElement } from 'vue'\n\nexport type State = {\n  isTopAffixed: boolean;\n  isBottomAffixed: boolean;\n  width?: number;\n}\n\ntype Coordinates = {\n  top: number;\n  bottom: number;\n}\n\ntype ValuesToComputeAffixedState = {\n  coordinates: Coordinates;\n  offsetTop?: number;\n  offsetBottom?: number;\n  target: HTMLElement | Window | undefined;\n}\n\nexport function getWindowHeight () {\n  return document.documentElement.clientHeight ||\n    window.innerHeight ||\n    document.body.clientHeight\n}\n\nexport function computeAffixedState ({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target,\n}: ValuesToComputeAffixedState): State {\n  let isTopAffixed = false\n  let isBottomAffixed = false\n\n  const windowHeight = getWindowHeight()\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop\n    } else {\n      const { top } = (target as HTMLElement).getBoundingClientRect()\n      isTopAffixed = coordinates.top - top <= offsetTop\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\n    } else {\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed,\n  }\n}\n\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\n}\n\nexport type Context = {\n  offsetTop?: number;\n  offsetBottom?: number;\n  element: VueElement | Element | VueElement[] | Element[];\n  target: HTMLElement | Window | undefined;\n  setState: (state: State) => void;\n  getState: () => State;\n  initialPosition?: ClientRect;\n}\n\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\n\n  let nextState\n\n  const isInitialCall = !eventName\n\n  // Fixme: getBoundingClientRect should always exist on element\n  const coordinates = (element as HTMLElement).getBoundingClientRect()\n\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target,\n  }\n\n  if (isInitialCall && initialPosition) {\n    nextState = computeAffixedState({ coordinates: initialPosition, ...options })\n  } else {\n    nextState = computeAffixedState({ coordinates, ...options })\n  }\n\n  const prevState = getState()\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState, width: coordinates.width })\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState, width: coordinates.width })\n  }\n}\n\nfunction useCaptureDefault (eventName: string) {\n  // This event type must bubble to the Window object only when dispatched on the Document element\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\n  return eventName === 'scroll'\n}\n\ntype Options = {\n  handler: (eventName: string, event: Event) => void;\n  useCapture?: (eventName: string) => boolean;\n  wait?: number;\n}\n\nexport function useEventsHandlerWithThrottle (events: string[], {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50,\n}: Options) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\n\n    window.addEventListener(eventName, _handler, useCapture(eventName))\n\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\n  })\n\n  return () => clearHandlersArray.forEach(clear => clear())\n}\n","<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, Ref, nextTick, onMounted, onBeforeUnmount } from 'vue'\nimport noop from 'lodash/noop.js'\nimport { getWindow } from '../../utils/ssr-utils'\n\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\ntype Target = HTMLElement | Window\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    offsetTop: { type: Number as PropType<number>, default: undefined },\n    offsetBottom: { type: Number as PropType<number>, default: undefined },\n    target: { type: [Object, Function] as PropType<Target | (() => Target)>, default: getWindow },\n  },\n  setup (props, { emit }) {\n    const getTargetElement = () => (typeof props.target === 'function' ? props.target() : props.target)\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state: Ref<State> = ref({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (!target) {\n        return 0\n      }\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (!target) { return 0 }\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }),\n    )\n\n    const initialPosition: Ref<undefined | DOMRect> = ref()\n    const element: Ref<HTMLElement | null> = ref(null)\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value!,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n    onBeforeUnmount(() => clearEventListeners())\n    onMounted(() => {\n      const events = ['scroll', 'resize']\n\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n","<template>\n  <div\n    ref=\"element\"\n    class=\"va-affix\"\n  >\n    <div :style=\"{ visibility: isAffixed ? 'hidden' : 'inherit' }\">\n      <slot />\n    </div>\n    <div\n      v-if=\"isAffixed\"\n      :class=\"computedClass\"\n      :style=\"computedStyle\"\n    >\n      <slot />\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport { defineComponent, computed, PropType, ref, Ref, nextTick, onMounted, onBeforeUnmount } from 'vue'\nimport noop from 'lodash/noop.js'\nimport { getWindow } from '../../utils/ssr-utils'\n\nimport {\n  handleThrottledEvent,\n  useEventsHandlerWithThrottle,\n  getWindowHeight,\n  State,\n  Context,\n} from './VaAffix-utils'\n\ntype Target = HTMLElement | Window\n\nexport default defineComponent({\n  name: 'VaAffix',\n  emits: ['change'],\n  props: {\n    offsetTop: { type: Number as PropType<number>, default: undefined },\n    offsetBottom: { type: Number as PropType<number>, default: undefined },\n    target: { type: [Object, Function] as PropType<Target | (() => Target)>, default: getWindow },\n  },\n  setup (props, { emit }) {\n    const getTargetElement = () => (typeof props.target === 'function' ? props.target() : props.target)\n\n    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed)\n\n    const state: Ref<State> = ref({\n      isTopAffixed: false,\n      isBottomAffixed: false,\n    })\n    const getState = () => state.value\n    const setState = (newState: State) => {\n      state.value = newState\n      emit('change', isAffixed)\n    }\n\n    const calculateTop = () => {\n      const target = getTargetElement()\n\n      if (!target) {\n        return 0\n      }\n\n      if (props.offsetTop === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { top } = target.getBoundingClientRect()\n        return top + props.offsetTop\n      }\n\n      return props.offsetTop\n    }\n\n    const calculateBottom = () => {\n      const target = getTargetElement()\n\n      if (!target) { return 0 }\n\n      if (props.offsetBottom === undefined) { return }\n\n      if (!(target instanceof Window)) {\n        const { bottom } = target.getBoundingClientRect()\n        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target)\n        const { offsetHeight, clientHeight } = target\n\n        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth)\n\n        return getWindowHeight() - (bottom - props.offsetBottom) + scrollBarHeight\n      }\n\n      return props.offsetBottom\n    }\n\n    const convertToPixels = (calculate: () => number | undefined) => {\n      const result = calculate()\n      return result === undefined ? undefined : `${result}px`\n    }\n\n    const computedClass = computed(() => [{ 'va-affix--affixed': isAffixed }])\n    const computedStyle = computed(() => ({\n      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : undefined,\n      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : undefined,\n      width: `${state.value.width}px`,\n    }),\n    )\n\n    const initialPosition: Ref<undefined | DOMRect> = ref()\n    const element: Ref<HTMLElement | null> = ref(null)\n    const throttledEventHandler = (eventName: string | null, event?: Event) => {\n      const context: Context = {\n        ...props,\n        initialPosition: initialPosition.value,\n        element: element.value!,\n        target: getTargetElement(),\n        setState,\n        getState,\n      }\n\n      if (!eventName || eventName === 'resize') {\n        handleThrottledEvent(eventName, context)\n      } else if (event && event.target) {\n        const target = getTargetElement()\n\n        if (target === event.target || target instanceof Window) {\n          handleThrottledEvent(eventName, context)\n        } else {\n          // if we have a custom target but keep scrolling on another element,\n          // so just disable the affixed state\n          setState({\n            isBottomAffixed: false,\n            isTopAffixed: false,\n          })\n        }\n      }\n    }\n\n    let clearEventListeners: () => any = noop\n    onBeforeUnmount(() => clearEventListeners())\n    onMounted(() => {\n      const events = ['scroll', 'resize']\n\n      initialPosition.value = element.value?.getBoundingClientRect()\n\n      clearEventListeners = useEventsHandlerWithThrottle(events, {\n        handler: throttledEventHandler,\n      })\n\n      nextTick(() => {\n        // pass `null` here to make sure it is an initial call\n        throttledEventHandler(null)\n      })\n    })\n\n    return {\n      computedClass,\n      computedStyle,\n      isAffixed,\n      element,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"variables\";\n\n.va-affix {\n  font-family: var(--va-font-family);\n\n  &--affixed {\n    position: var(--va-affix-affixed-position);\n    z-index: var(--va-affix-affixed-z-index);\n  }\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport VaAffix from './VaAffix.vue'\n\nexport default withConfigTransport(VaAffix)\n"],"names":["noop","debounce","require$$0","isObject","require$$1","throttle_1","throttle","func","wait","options","leading","trailing","TypeError","maxWait","getWindowHeight","document","documentElement","clientHeight","window","innerHeight","body","computeAffixedState","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","top","getBoundingClientRect","bottom","handleThrottledEvent","eventName","context","element","setState","getState","initialPosition","nextState","isInitialCall","prevState","checkAffixedStateChange","currentState","width","useCaptureDefault","defineComponent","name","emits","props","type","Number","default","undefined","Object","Function","getWindow","setup","emit","getTargetElement","isAffixed","computed","state","value","ref","newState","calculateTop","Window","calculateBottom","borderTopWidth","borderBottomWidth","getComputedStyle","offsetHeight","scrollBarHeight","parseInt","convertToPixels","calculate","result","computedClass","computedStyle","throttledEventHandler","event","clearEventListeners","onBeforeUnmount","onMounted","useEventsHandlerWithThrottle","events","handler","useCapture","clearHandlersArray","map","_handler","addEventListener","removeEventListener","forEach","clear","nextTick","class","_createElementBlock","_hoisted_1","_createElementVNode","style","_ctx","_renderSlot","withConfigTransport","VaAffix"],"mappings":"seAYA,SAASA,SCZLC,EAAWC,EACXC,EAAWC,MAmEfC,EAlBA,SAASC,SAASC,EAAMC,EAAMC,GAC5B,IAAIC,GAAU,EACVC,GAAW,EAEf,GAAmB,mBAARJ,EACT,MAAM,IAAIK,UAnDQ,uBAyDpB,OAJIT,EAASM,KACXC,EAAU,YAAaD,IAAYA,EAAQC,QAAUA,EACrDC,EAAW,aAAcF,IAAYA,EAAQE,SAAWA,GAEnDV,EAASM,EAAMC,EAAM,CAC1BE,QAAWA,EACXG,QAAWL,EACXG,SAAYA,cC3CAG,kBACd,OAAOC,SAASC,gBAAgBC,cAC9BC,OAAOC,aACPJ,SAASK,KAAKH,sBAGFI,qBAAqBC,YACnCA,EAAWC,UACXA,EAASC,aACTA,EAAYC,OACZA,IAEA,IAAIC,GAAe,EACfC,GAAkB,EAEtB,MAAMC,EAAed,kBAErB,GAAiB,MAAbS,GAAqBK,EACvB,GAAIH,IAAWP,OACbQ,EAAeJ,EAAYO,KAAON,MAC7B,CACL,MAAMM,IAAEA,GAASJ,EAAuBK,wBACxCJ,EAAeJ,EAAYO,IAAMA,GAAON,EAI5C,GAAoB,MAAhBC,GAAwBI,EAC1B,GAAIH,IAAWP,OACbS,EAAkBL,EAAYS,QAAUH,EAAeJ,MAClD,CACL,MAAMO,OAAEA,GAAYN,EAAuBK,wBAC3CH,EAAkBI,EAAST,EAAYS,QAAUP,EAIrD,MAAO,CACLE,aAAAA,EACAC,gBAAAA,YAmBYK,qBAAsBC,EAA0BC,GAC9D,MAAMT,OAAEA,EAAMU,QAAEA,EAAOZ,UAAEA,EAASC,aAAEA,EAAYY,SAAEA,EAAQC,SAAEA,EAAQC,gBAAEA,GAAoBJ,EAE1F,IAAIK,EAEJ,MAAMC,GAAiBP,EAGjBX,EAAea,EAAwBL,wBAEvCrB,EAAU,CACde,aAAAA,EACAD,UAAAA,EACAE,OAAAA,GAIAc,EAAYlB,oBADVmB,GAAiBF,EACa,CAAEhB,YAAagB,KAAoB7B,GAEnC,CAAEa,YAAAA,KAAgBb,IAGpD,MAAMgC,EAAYJ,KArCpB,SAASK,wBAAyBC,EAAqBJ,GACrD,OAAOI,EAAajB,eAAiBa,EAAUb,cAC7CiB,EAAahB,kBAAoBY,EAAUZ,gBAqCzCe,CAAwBD,EAAWF,GAE5BE,EAAUG,QAAUtB,EAAYsB,OACzCR,EAAS,IAAKK,EAAWG,MAAOtB,EAAYsB,QAF5CR,EAAS,IAAKG,EAAWK,MAAOtB,EAAYsB,QAMhD,SAASC,kBAAmBZ,GAG1B,MAAqB,WAAdA,EC/ET,MAAea,EAAgB,CAC7BC,KAAM,UACNC,MAAO,CAAC,UACRC,MAAO,CACL1B,UAAW,CAAE2B,KAAMC,OAA4BC,aAASC,GACxD7B,aAAc,CAAE0B,KAAMC,OAA4BC,aAASC,GAC3D5B,OAAQ,CAAEyB,KAAM,CAACI,OAAQC,UAAgDH,QAASI,IAEpFC,MAAOR,GAAOS,KAAEA,IACd,MAAMC,iBAAmB,IAA+B,mBAAjBV,EAAMxB,OAAwBwB,EAAMxB,SAAWwB,EAAMxB,OAEtFmC,EAAYC,GAAS,IAAMC,EAAMC,MAAMrC,cAAgBoC,EAAMC,MAAMpC,kBAEnEmC,EAAoBE,EAAI,CAC5BtC,cAAc,EACdC,iBAAiB,IAEbU,SAAW,IAAMyB,EAAMC,MACvB3B,SAAY6B,IAChBH,EAAMC,MAAQE,EACdP,EAAK,SAAUE,IAGXM,aAAe,KACnB,MAAMzC,EAASkC,mBAEf,IAAKlC,EACH,OAAO,EAGT,QAAwB4B,IAApBJ,EAAM1B,UAAV,CAEA,KAAME,aAAkB0C,QAAS,CAC/B,MAAMtC,IAAEA,GAAQJ,EAAOK,wBACvB,OAAOD,EAAMoB,EAAM1B,UAGrB,OAAO0B,EAAM1B,YAGT6C,gBAAkB,KACtB,MAAM3C,EAASkC,mBAEf,IAAKlC,EAAU,OAAO,EAEtB,QAA2B4B,IAAvBJ,EAAMzB,aAAV,CAEA,KAAMC,aAAkB0C,QAAS,CAC/B,MAAMpC,OAAEA,GAAWN,EAAOK,yBACpBuC,eAAEA,EAAcC,kBAAEA,GAAsBC,iBAAiB9C,IACzD+C,aAAEA,EAAYvD,aAAEA,GAAiBQ,EAEjCgD,EAAkBD,EAAevD,EAAeyD,SAASL,GAAkBK,SAASJ,GAE1F,OAAOxD,mBAAqBiB,EAASkB,EAAMzB,cAAgBiD,EAG7D,OAAOxB,EAAMzB,eAGTmD,gBAAmBC,IACvB,MAAMC,EAASD,IACf,YAAkBvB,IAAXwB,OAAuBxB,EAAY,GAAGwB,OAGzCC,EAAgBjB,GAAS,IAAM,CAAC,CAAE,oBAAqBD,MACvDmB,EAAgBlB,GAAS,MAC7BhC,IAAKiC,EAAMC,MAAMrC,aAAeiD,gBAAgBT,mBAAgBb,EAChEtB,OAAQ+B,EAAMC,MAAMpC,gBAAkBgD,gBAAgBP,sBAAmBf,EACzET,MAAO,GAAGkB,EAAMC,MAAMnB,cAIlBN,EAA4C0B,IAC5C7B,EAAmC6B,EAAI,MACvCgB,sBAAwB,CAAC/C,EAA0BgD,KACvD,MAAM/C,EAAmB,IACpBe,EACHX,gBAAiBA,EAAgByB,MACjC5B,QAASA,EAAQ4B,MACjBtC,OAAQkC,mBACRvB,SAAAA,SACAC,SAAAA,UAGF,GAAKJ,GAA2B,WAAdA,GAEX,GAAIgD,GAASA,EAAMxD,OAAQ,CAChC,MAAMA,EAASkC,mBAEXlC,IAAWwD,EAAMxD,QAAUA,aAAkB0C,OAC/CnC,qBAAqBC,EAAWC,GAIhCE,SAAS,CACPT,iBAAiB,EACjBD,cAAc,UAXlBM,qBAAqBC,EAAWC,IAiBpC,IAAIgD,EAAiClF,EAiBrC,OAhBAmF,GAAgB,IAAMD,MACtBE,GAAU,WAGR9C,EAAgByB,gBAAQ5B,EAAQ4B,4BAAOjC,wBAEvCoD,WDtBUG,6BAA8BC,GAAkBC,QAC9DA,EAAOC,WACPA,EAAa3C,kBAAiBrC,KAC9BA,EAAO,KAEP,MAAMiF,EAAqBH,EAAOI,KAAIzD,IACpC,MAAM0D,EAAWrF,GAAU2E,GAAiBM,EAAQtD,EAAWgD,IAAQzE,GAIvE,OAFAU,OAAO0E,iBAAiB3D,EAAW0D,EAAUH,EAAWvD,IAEjD,IAAMf,OAAO2E,oBAAoB5D,EAAW0D,EAAUH,EAAWvD,OAG1E,MAAO,IAAMwD,EAAmBK,SAAQC,GAASA,MCSvBV,CAJP,CAAC,SAAU,UAIiC,CACzDE,QAASP,wBAGXgB,GAAS,KAEPhB,sBAAsB,YAInB,CACLF,cAAAA,EACAC,cAAAA,EACAnB,UAAAA,EACAzB,QAAAA,eC1JF6B,IAAI,UACJiC,MAAM,6DAFRC,QAAAC,GAIEC,SAAMC,oBAAqBC,mCACzBC,0BAGMD,EAAS,eADjBJ,eAEGD,QAAOK,iBACPD,QAAOC,mBAERC,8FCVN,MAAeC,EAAoBC"}