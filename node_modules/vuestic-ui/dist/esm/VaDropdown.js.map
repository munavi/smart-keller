{"version":3,"file":"VaDropdown.js","sources":["../../src/composables/useDomRect.ts","../../src/utils/map-object.ts","../../src/composables/usePopover.ts","../../src/composables/useClientOnly.ts","../../src/composables/useDebounce.ts","../../src/composables/useClickOutside.ts","../../src/components/va-dropdown/VaDropdown.vue","../../src/components/va-dropdown/VaDropdown.vue?vue&type=template&id=6d4e48a8&lang.js"],"sourcesContent":["import { onBeforeUnmount, onMounted, Ref, ref, watch } from 'vue'\n\nconst createDOMRectObserver = (target: HTMLElement, cb: (domRect: DOMRect) => void) => {\n  let prevDomRect: DOMRect\n  let animationFrameRequest = -1\n\n  const update = () => {\n    const domRect = target.getBoundingClientRect()\n    cb(domRect)\n  }\n\n  const observeKeys = ['x', 'y', 'width', 'height', 'top', 'left', 'bottom', 'right'] as const\n  const observe = () => {\n    animationFrameRequest = requestAnimationFrame(observe)\n\n    const domRect = target.getBoundingClientRect()\n\n    if (!prevDomRect) {\n      cb(domRect)\n      prevDomRect = domRect\n      return\n    }\n\n    if (observeKeys.some((key) => domRect[key] !== prevDomRect[key])) {\n      cb(domRect)\n      prevDomRect = domRect\n    }\n  }\n\n  observe()\n\n  return () => {\n    cancelAnimationFrame(animationFrameRequest)\n  }\n}\n\nexport const useDomRectCallback = (target: Ref<HTMLElement | null | undefined>, cb: (domRect: DOMRect | null) => void) => {\n  let unObserve: (() => void) | null = null\n\n  const observe = () => {\n    unObserve?.()\n\n    if (!target.value) { cb(null); return }\n\n    unObserve = createDOMRectObserver(target.value, (newDomRect) => {\n      cb(newDomRect)\n    })\n  }\n\n  watch(target, () => { observe() })\n\n  onMounted(() => { observe() })\n  onBeforeUnmount(() => { unObserve?.() })\n}\n\nexport const useDomRect = (target: Ref<HTMLElement | null | undefined>) => {\n  const domRect = ref<DOMRect | null>(null)\n\n  let unObserve: (() => void) | null = null\n\n  const observe = () => {\n    unObserve?.()\n\n    if (!target.value) { domRect.value = null; return }\n\n    unObserve = createDOMRectObserver(target.value, (newDomRect) => {\n      domRect.value = newDomRect\n    })\n  }\n\n  onMounted(() => { observe() })\n  onBeforeUnmount(() => { unObserve?.() })\n\n  watch(target, () => { observe() })\n\n  return {\n    domRect,\n  }\n}\n","export const mapObject = <T, D, K extends string>(o: Record<K, T>, cb: (item: T, key: K) => D) => {\n  const copy = {} as Record<K, D>\n\n  (Object.keys(o) as K[])\n    .forEach((key: K) => {\n      copy[key] = cb(o[key], key)\n    })\n\n  return copy\n}\n","import { computed, onBeforeUnmount, onMounted, Ref, unref, watch } from 'vue'\nimport { useDomRect } from './useDomRect'\nimport { mapObject } from '../utils/map-object'\nimport { useClientOnly } from './useClientOnly'\n\nexport type PlacementPosition = 'top' | 'bottom' | 'left' | 'right'\nexport type PlacementAlignment = 'start' | 'end' | 'center'\nexport type Placement = PlacementPosition | 'auto' | `${PlacementPosition}-${PlacementAlignment}`\nexport type Offset = number | [number, number]\n\ntype Coords = { x: number, y: number }\ntype AlignCoords = { main: number, cross: number }\n\nexport const placementsPositions = ['top', 'bottom', 'left', 'right']\n  .reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ['auto'] as string[])\n\nconst coordsToCss = ({ x, y }: Coords) => ({ left: `${x}px`, top: `${y}px` })\n\nconst parsePlacement = (placement: Placement) => {\n  const [position, align] = placement.split('-') as [PlacementPosition, PlacementAlignment | undefined]\n\n  return { position, align: align || 'center' }\n}\n\nconst parseOffset = (offset: Offset): AlignCoords => {\n  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 }\n}\n\nconst calculateContentAlignment = (align: PlacementAlignment, anchorStart: number, anchorSize: number, contentSize: number) => {\n  if (align === 'start') { return anchorStart }\n  if (align === 'end') { return anchorStart + anchorSize - contentSize }\n\n  return anchorStart + (anchorSize - contentSize) / 2\n}\n\nconst calculateContentCoords = (placement: Placement, anchor: DOMRect, content: DOMRect) => {\n  const { position, align } = parsePlacement(placement)\n\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width)\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height)\n\n  switch (position) {\n    case 'top': return { x: alignmentX, y: anchor.top - content.height }\n    case 'left': return { y: alignmentY, x: anchor.left - content.width }\n    case 'right': return { y: alignmentY, x: anchor.right }\n    case 'bottom':\n    default: return { x: alignmentX, y: anchor.bottom }\n  }\n}\n\nconst calculateOffsetCoords = (placement: Placement, offset: Offset): Coords => {\n  const { position } = parsePlacement(placement)\n  const { main, cross } = parseOffset(offset)\n\n  switch (position) {\n    case 'left': return { y: cross, x: -main }\n    case 'right': return { y: cross, x: main }\n    case 'top': return { y: -main, x: cross }\n    case 'bottom':\n    default: return { y: main, x: cross }\n  }\n}\n\n/** Returns how much content overflow */\nconst calculateContentOverflow = (coords: Coords, content: DOMRect, root: DOMRect) => {\n  const xMax = root.right\n  const yMax = root.bottom\n  const xMin = root.left\n  const yMin = root.top\n\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max((coords.y + content.height) - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max((coords.x + content.width) - xMax, 0),\n  }\n}\n\nconst clamp = (min: number, v: number, max: number) => Math.max(Math.min(v, max), min)\n\nconst calculateClipToEdge = (coords: Coords, offsetCoords: Coords, content: DOMRect, anchor: DOMRect, root: DOMRect) => {\n  const { top, bottom, left, right } = calculateContentOverflow(coords, content, root)\n\n  // Add left overflow, sub right overflow so content always stick to edge\n  const x = coords.x - right + left\n  const y = coords.y - bottom + top\n\n  const { x: offsetX, y: offsetY } = offsetCoords\n\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),\n  }\n}\n\nconst getAutoPlacement = (placement: Placement, coords: Coords, content: DOMRect, root: DOMRect): Placement => {\n  const { position, align } = parsePlacement(placement)\n  const overflow = calculateContentOverflow(coords, content, root)\n\n  const newPlacements = {\n    top: ['bottom', align].join('-') as Placement,\n    bottom: ['top', align].join('-') as Placement,\n    right: ['left', align].join('-') as Placement,\n    left: ['right', align].join('-') as Placement,\n  }\n\n  return overflow[position] ? newPlacements[position] : placement\n}\n\nexport type usePopoverOptions = {\n  keepAnchorWidth?: boolean,\n  autoPlacement?: boolean,\n  stickToEdges?: boolean,\n  placement: Placement,\n  offset?: Offset,\n  /** Root element selector */\n  root?: string\n}\n\n/**\n * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`\n * @param options make options reactive if you want popover to react on options change.\n */\nexport const usePopover = (\n  anchorRef: Ref<HTMLElement | null | undefined>,\n  contentRef: Ref<HTMLElement | null | undefined>,\n  options: usePopoverOptions | Ref<usePopoverOptions>,\n) => {\n  const documentRef = useClientOnly(() => document)\n  const rootRef = computed(() => {\n    if (!documentRef.value) { return undefined }\n\n    const { root } = unref(options)\n\n    if (root) { return documentRef.value.querySelector(root) }\n\n    return documentRef.value.body\n  })\n  const { domRect: anchorDomRect } = useDomRect(anchorRef)\n  const { domRect: contentDomRect } = useDomRect(contentRef)\n\n  const updateContentCSS = () => {\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) { return }\n\n    let offsetCoords: Coords = { x: 0, y: 0 }\n\n    const css = {\n      width: 'max-content',\n      position: 'fixed',\n    }\n\n    const { placement, keepAnchorWidth, offset, autoPlacement, stickToEdges } = unref(options)\n\n    // calculate coords (x and y) of content left-top corner\n    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value)\n\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(placement, offset)\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n    }\n\n    if (keepAnchorWidth) {\n      const { width } = anchorDomRect.value\n      Object.assign(css, { width: `${width}px`, maxWidth: `${width}px` })\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect()\n\n    if (autoPlacement) {\n      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, rootRect)\n      if (newPlacement !== placement) {\n        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value)\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPlacement, offset)\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, rootRect)\n    }\n\n    Object.assign(contentRef.value?.style, {\n      ...css,\n      ...coordsToCss(coords),\n    })\n  }\n\n  watch(anchorDomRect, updateContentCSS)\n  watch(contentDomRect, updateContentCSS)\n  watch(options, updateContentCSS, { deep: true })\n\n  onMounted(() => { window.addEventListener('resize', updateContentCSS) })\n  onBeforeUnmount(() => { window.removeEventListener('resize', updateContentCSS) })\n\n  return {\n    anchorDomRect,\n    contentDomRect,\n  }\n}\n","import { onMounted, ref, UnwrapRef } from 'vue'\nimport { isServer } from '../utils/ssr-utils'\n\n/** Returns cb result only on client. Returns null on server  */\nexport const useClientOnly = <T>(cb: () => T) => {\n  if (isServer()) {\n    const result = ref<T | null>(null)\n\n    onMounted(() => { result.value = cb() as UnwrapRef<T> })\n\n    return result\n  }\n\n  return ref(cb())\n}\n","import { isRef, Ref, unref, watch } from 'vue'\nimport debounce from 'lodash/debounce.js'\n\nexport const useDebounce = <T>(onUpdate: () => any, timeout: Ref<number> | number) => {\n  const createDebounced = () => {\n    return debounce(() => {\n      onUpdate()\n    }, unref(timeout))\n  }\n\n  let debounced = createDebounced()\n\n  if (isRef(timeout)) {\n    watch(timeout, () => { debounced = createDebounced() })\n  }\n\n  return {\n    // todo check if we need to create proxy here\n    debounced,\n  }\n}\n\n/** Used for debounced callbacks. Can be used to show cb near debounce call in code structure. */\nexport const useDebounceFn = (timeout: Ref<number> | number) => {\n  let callback: (() => void) | null = null\n  const createDebounced = () => {\n    return debounce(() => {\n      callback?.()\n      callback = null\n    }, unref(timeout))\n  }\n\n  let debounced = createDebounced()\n\n  if (isRef(timeout)) {\n    watch(timeout, () => { debounced = createDebounced() })\n  }\n\n  return {\n    // todo check if we need to create proxy here\n    debounced: (cb: (() => void)) => { callback = cb; debounced() },\n    cancel: () => debounced.cancel(),\n  }\n}\n","import { onBeforeUnmount, onMounted, Ref, unref } from 'vue'\n\nconst checkIfElementChild = (parent: HTMLElement, child: HTMLElement | null | undefined): boolean => {\n  if (!child) { return false }\n  if (child.parentElement === parent) { return true }\n\n  return checkIfElementChild(parent, child.parentElement)\n}\n\ntype MaybeRef<T> = T | Ref<T>\ntype MaybeArray<T> = T | T[]\n\nconst safeArray = <T>(a: MaybeArray<T>) => Array.isArray(a) ? a : [a]\n\nexport const useClickOutside = (elements: MaybeArray<MaybeRef<HTMLElement>>, cb: (el: HTMLElement) => void) => {\n  const clickHandler = (event: MouseEvent) => {\n    const clickTarget = event.target as HTMLElement\n\n    const isClickInside = safeArray(elements)\n      .some((element) => unref(element) && checkIfElementChild(unref(element), clickTarget))\n\n    if (!isClickInside) { cb(clickTarget) }\n  }\n\n  onMounted(() => { window.addEventListener('click', clickHandler) })\n  onBeforeUnmount(() => { window.removeEventListener('click', clickHandler) })\n}\n","<template>\n  <div\n    class=\"va-dropdown\"\n    :class=\"computedClass\"\n  >\n    <div\n      class=\"va-dropdown__anchor\"\n      @click=\"onAnchorClick()\"\n      @mouseenter=\"onMouseEnter()\"\n      @mouseleave=\"onMouseLeave()\"\n      @keyup.enter.stop.prevent=\"onAnchorClick()\"\n      ref=\"anchorRef\"\n    >\n      <slot name=\"anchor\" />\n    </div>\n    <template v-if=\"valueComputed\">\n      <teleport :to=\"attachElement\" :disabled=\"disableAttachment\">\n        <div\n          class=\"va-dropdown__content-wrapper\"\n          @mouseover=\"$props.isContentHoverable && onMouseEnter()\"\n          @mouseout=\"onMouseLeave()\"\n          @click.stop=\"emitAndClose('dropdown-content-click', closeOnContentClick)\"\n          ref=\"contentRef\"\n        >\n          <slot />\n        </div>\n      </teleport>\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, PropType, ref, toRef } from 'vue'\nimport { useStateful, useStatefulEmits, useStatefulProps } from '../../composables/useStateful'\nimport { useDebounceFn } from '../../composables/useDebounce'\nimport { usePopover, placementsPositions, Placement } from '../../composables/usePopover'\nimport { useClickOutside } from '../../composables/useClickOutside'\n\nexport default defineComponent({\n  name: 'VaDropdown',\n\n  props: {\n    ...useStatefulProps,\n    stateful: { default: true },\n    modelValue: { type: Boolean, default: false },\n    disabled: { type: Boolean },\n    anchorSelector: { type: String, default: '' },\n    attachElement: { type: String, default: 'body' },\n    disableAttachment: { type: Boolean, default: false },\n    keepAnchorWidth: { type: Boolean, default: false },\n    isContentHoverable: { type: Boolean, default: true },\n    closeOnContentClick: { type: Boolean, default: true },\n    closeOnClickOutside: { type: Boolean, default: true },\n    closeOnAnchorClick: { type: Boolean, default: true },\n    hoverOverTimeout: { type: Number, default: 30 },\n    hoverOutTimeout: { type: Number, default: 200 },\n    offset: { type: [Array, Number] as PropType<number | [number, number]>, default: () => 0 },\n    trigger: {\n      type: String as PropType<'click' | 'hover' | 'none'>,\n      default: 'click',\n      validator: (trigger: string) => ['click', 'hover', 'none'].includes(trigger),\n    },\n    placement: {\n      type: String as PropType<Placement>,\n      default: 'bottom',\n      validator: (placement: string) => placementsPositions.includes(placement),\n    },\n  },\n\n  emits: [...useStatefulEmits, 'anchor-click', 'dropdown-content-click', 'click-outside'],\n\n  setup (props, { emit }) {\n    const anchorRef = ref()\n    const contentRef = ref()\n    const { valueComputed } = useStateful(props, emit)\n\n    const computedClass = computed(() => ({\n      'va-dropdown': true,\n      'va-dropdown--disabled': props.disabled,\n    }))\n\n    // to be able to select specific anchor element inside anchorRef\n    const computedAnchorRef = computed(() => {\n      return (anchorRef.value && props.anchorSelector)\n        ? anchorRef.value.querySelector(props.anchorSelector) || anchorRef.value\n        : anchorRef.value\n    })\n\n    usePopover(computedAnchorRef, contentRef, computed(() => ({\n      placement: props.placement,\n      keepAnchorWidth: props.keepAnchorWidth,\n      offset: props.offset,\n      stickToEdges: true,\n      autoPlacement: true,\n      root: props.attachElement,\n    })))\n\n    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, 'hoverOverTimeout'))\n    const onMouseEnter = () => {\n      if (props.trigger !== 'hover' || props.disabled) { return }\n\n      debounceHover(() => { valueComputed.value = true })\n      cancelUnHoverDebounce()\n    }\n\n    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, 'hoverOutTimeout'))\n    const onMouseLeave = () => {\n      if (props.trigger !== 'hover' || props.disabled) { return }\n\n      if (props.isContentHoverable) {\n        debounceUnHover(() => { valueComputed.value = false })\n      } else {\n        valueComputed.value = false\n      }\n      cancelHoverDebounce()\n    }\n\n    const emitAndClose = (eventName: string, close?: boolean) => {\n      emit(eventName)\n      if (close) { valueComputed.value = false }\n    }\n\n    const onAnchorClick = () => {\n      if (props.trigger !== 'click' || props.disabled) { return }\n\n      if (valueComputed.value) {\n        emitAndClose('anchor-click', props.closeOnAnchorClick)\n      } else {\n        valueComputed.value = true\n        emit('anchor-click')\n      }\n    }\n\n    useClickOutside([anchorRef, contentRef], () => {\n      if (props.closeOnClickOutside && valueComputed.value) {\n        emitAndClose('click-outside', props.closeOnClickOutside)\n      }\n    })\n\n    return {\n      valueComputed,\n      anchorRef,\n      contentRef,\n      computedClass,\n      emitAndClose,\n      onAnchorClick,\n      onMouseEnter,\n      onMouseLeave,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import '../../styles/resources';\n@import 'variables';\n\n.va-dropdown {\n  /* Solved the alignment problem (if we try to align inline and block elements) */\n  line-height: var(--va-dropdown-line-height);\n  font-family: var(--va-font-family);\n\n  &--disabled {\n    @include va-disabled;\n  }\n\n  &__content-wrapper {\n    /* overflow: hidden; */\n    z-index: var(--va-dropdown-content-wrapper-z-index);\n  }\n}\n</style>\n","<template>\n  <div\n    class=\"va-dropdown\"\n    :class=\"computedClass\"\n  >\n    <div\n      class=\"va-dropdown__anchor\"\n      @click=\"onAnchorClick()\"\n      @mouseenter=\"onMouseEnter()\"\n      @mouseleave=\"onMouseLeave()\"\n      @keyup.enter.stop.prevent=\"onAnchorClick()\"\n      ref=\"anchorRef\"\n    >\n      <slot name=\"anchor\" />\n    </div>\n    <template v-if=\"valueComputed\">\n      <teleport :to=\"attachElement\" :disabled=\"disableAttachment\">\n        <div\n          class=\"va-dropdown__content-wrapper\"\n          @mouseover=\"$props.isContentHoverable && onMouseEnter()\"\n          @mouseout=\"onMouseLeave()\"\n          @click.stop=\"emitAndClose('dropdown-content-click', closeOnContentClick)\"\n          ref=\"contentRef\"\n        >\n          <slot />\n        </div>\n      </teleport>\n    </template>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, PropType, ref, toRef } from 'vue'\nimport { useStateful, useStatefulEmits, useStatefulProps } from '../../composables/useStateful'\nimport { useDebounceFn } from '../../composables/useDebounce'\nimport { usePopover, placementsPositions, Placement } from '../../composables/usePopover'\nimport { useClickOutside } from '../../composables/useClickOutside'\n\nexport default defineComponent({\n  name: 'VaDropdown',\n\n  props: {\n    ...useStatefulProps,\n    stateful: { default: true },\n    modelValue: { type: Boolean, default: false },\n    disabled: { type: Boolean },\n    anchorSelector: { type: String, default: '' },\n    attachElement: { type: String, default: 'body' },\n    disableAttachment: { type: Boolean, default: false },\n    keepAnchorWidth: { type: Boolean, default: false },\n    isContentHoverable: { type: Boolean, default: true },\n    closeOnContentClick: { type: Boolean, default: true },\n    closeOnClickOutside: { type: Boolean, default: true },\n    closeOnAnchorClick: { type: Boolean, default: true },\n    hoverOverTimeout: { type: Number, default: 30 },\n    hoverOutTimeout: { type: Number, default: 200 },\n    offset: { type: [Array, Number] as PropType<number | [number, number]>, default: () => 0 },\n    trigger: {\n      type: String as PropType<'click' | 'hover' | 'none'>,\n      default: 'click',\n      validator: (trigger: string) => ['click', 'hover', 'none'].includes(trigger),\n    },\n    placement: {\n      type: String as PropType<Placement>,\n      default: 'bottom',\n      validator: (placement: string) => placementsPositions.includes(placement),\n    },\n  },\n\n  emits: [...useStatefulEmits, 'anchor-click', 'dropdown-content-click', 'click-outside'],\n\n  setup (props, { emit }) {\n    const anchorRef = ref()\n    const contentRef = ref()\n    const { valueComputed } = useStateful(props, emit)\n\n    const computedClass = computed(() => ({\n      'va-dropdown': true,\n      'va-dropdown--disabled': props.disabled,\n    }))\n\n    // to be able to select specific anchor element inside anchorRef\n    const computedAnchorRef = computed(() => {\n      return (anchorRef.value && props.anchorSelector)\n        ? anchorRef.value.querySelector(props.anchorSelector) || anchorRef.value\n        : anchorRef.value\n    })\n\n    usePopover(computedAnchorRef, contentRef, computed(() => ({\n      placement: props.placement,\n      keepAnchorWidth: props.keepAnchorWidth,\n      offset: props.offset,\n      stickToEdges: true,\n      autoPlacement: true,\n      root: props.attachElement,\n    })))\n\n    const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(toRef(props, 'hoverOverTimeout'))\n    const onMouseEnter = () => {\n      if (props.trigger !== 'hover' || props.disabled) { return }\n\n      debounceHover(() => { valueComputed.value = true })\n      cancelUnHoverDebounce()\n    }\n\n    const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(toRef(props, 'hoverOutTimeout'))\n    const onMouseLeave = () => {\n      if (props.trigger !== 'hover' || props.disabled) { return }\n\n      if (props.isContentHoverable) {\n        debounceUnHover(() => { valueComputed.value = false })\n      } else {\n        valueComputed.value = false\n      }\n      cancelHoverDebounce()\n    }\n\n    const emitAndClose = (eventName: string, close?: boolean) => {\n      emit(eventName)\n      if (close) { valueComputed.value = false }\n    }\n\n    const onAnchorClick = () => {\n      if (props.trigger !== 'click' || props.disabled) { return }\n\n      if (valueComputed.value) {\n        emitAndClose('anchor-click', props.closeOnAnchorClick)\n      } else {\n        valueComputed.value = true\n        emit('anchor-click')\n      }\n    }\n\n    useClickOutside([anchorRef, contentRef], () => {\n      if (props.closeOnClickOutside && valueComputed.value) {\n        emitAndClose('click-outside', props.closeOnClickOutside)\n      }\n    })\n\n    return {\n      valueComputed,\n      anchorRef,\n      contentRef,\n      computedClass,\n      emitAndClose,\n      onAnchorClick,\n      onMouseEnter,\n      onMouseLeave,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import '../../styles/resources';\n@import 'variables';\n\n.va-dropdown {\n  /* Solved the alignment problem (if we try to align inline and block elements) */\n  line-height: var(--va-dropdown-line-height);\n  font-family: var(--va-font-family);\n\n  &--disabled {\n    @include va-disabled;\n  }\n\n  &__content-wrapper {\n    /* overflow: hidden; */\n    z-index: var(--va-dropdown-content-wrapper-z-index);\n  }\n}\n</style>\n"],"names":["useDomRect","target","domRect","ref","unObserve","observe","value","cb","prevDomRect","animationFrameRequest","observeKeys","requestAnimationFrame","getBoundingClientRect","some","key","cancelAnimationFrame","createDOMRectObserver","newDomRect","onMounted","onBeforeUnmount","watch","mapObject","o","copy","Object","keys","forEach","placementsPositions","reduce","acc","position","coordsToCss","x","y","left","top","parsePlacement","placement","align","split","calculateContentAlignment","anchorStart","anchorSize","contentSize","calculateContentCoords","anchor","content","alignmentX","width","alignmentY","height","right","bottom","calculateOffsetCoords","offset","main","cross","Array","isArray","parseOffset","calculateContentOverflow","coords","root","xMax","yMax","xMin","yMin","Math","max","clamp","min","v","usePopover","anchorRef","contentRef","options","documentRef","isServer","result","useClientOnly","document","rootRef","computed","unref","querySelector","body","anchorDomRect","contentDomRect","updateContentCSS","offsetCoords","css","keepAnchorWidth","autoPlacement","stickToEdges","c","assign","maxWidth","rootRect","newPlacement","overflow","newPlacements","join","getAutoPlacement","offsetX","offsetY","calculateClipToEdge","style","deep","window","addEventListener","removeEventListener","useDebounceFn","timeout","callback","createDebounced","debounce","debounced","isRef","cancel","checkIfElementChild","parent","child","parentElement","useClickOutside","elements","clickHandler","event","clickTarget","a","element","defineComponent","name","props","useStatefulProps","stateful","default","modelValue","type","Boolean","disabled","anchorSelector","String","attachElement","disableAttachment","isContentHoverable","closeOnContentClick","closeOnClickOutside","closeOnAnchorClick","hoverOverTimeout","Number","hoverOutTimeout","trigger","validator","includes","emits","useStatefulEmits","setup","emit","valueComputed","useStateful","computedClass","computedAnchorRef","debounceHover","cancelHoverDebounce","toRef","debounceUnHover","cancelUnHoverDebounce","emitAndClose","eventName","close","onAnchorClick","onMouseEnter","onMouseLeave","_createElementBlock","class","_ctx","_createElementVNode","onClick","onMouseenter","onMouseleave","onKeyup","_renderSlot","_createBlock","to","onMouseover","onMouseout"],"mappings":"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"}