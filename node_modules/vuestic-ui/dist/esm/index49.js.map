{"version":3,"file":"index49.js","sources":["../../src/components/va-form/VaForm.vue","../../src/components/va-form/VaForm.vue?vue&type=template&id=848ce870&lang.js","../../src/components/va-form/index.ts"],"sourcesContent":["<template>\n  <component\n    ref=\"form\"\n    class=\"va-form\"\n    :is=\"tag\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  PropType,\n  ref,\n  Ref,\n  onMounted,\n  onUnmounted,\n  nextTick,\n  provide,\n  inject,\n} from 'vue'\n\nimport { FormServiceKey, FormChild, Form } from './consts'\n\nconst isVaForm = (value: any): value is Form => !!value.focusInvalid\n\nexport default defineComponent({\n  name: 'VaForm',\n  emits: ['validation'],\n  props: {\n    autofocus: { type: Boolean as PropType<boolean>, default: false },\n    tag: { type: String as PropType<string>, default: 'div' },\n  },\n\n  setup (props, { emit }) {\n    const nestedFormElements: Ref<(FormChild | Form)[]> = ref([])\n\n    const parentFormProvider = () => inject(FormServiceKey, undefined)\n\n    provide(FormServiceKey, {\n      onChildMounted: (child: FormChild | Form) => childMountedHandler(child),\n      onChildUnmounted: (removableChild: FormChild | Form) => childUnmountedHandler(removableChild),\n    })\n\n    const childMountedHandler = (child: FormChild | Form) => {\n      nestedFormElements.value.push(child)\n    }\n\n    const childUnmountedHandler = (removableChild: FormChild | Form) => {\n      nestedFormElements.value = nestedFormElements.value.filter(child => child !== removableChild)\n    }\n\n    /** @public */\n    const reset = () => {\n      nestedFormElements.value\n        .filter(({ reset }) => reset)\n        .forEach((item) => { item.reset() })\n    }\n\n    const resetValidation = () => {\n      nestedFormElements.value\n        .filter(({ resetValidation }) => resetValidation)\n        .forEach((item: any) => { item.resetValidation() })\n    }\n\n    const focus = () => { nestedFormElements.value.find(({ focus }) => focus)?.focus() }\n\n    const focusInvalid = () => {\n      const invalidComponent = nestedFormElements.value\n        .find((item) => !isVaForm(item) && item.hasError())\n\n      if (invalidComponent) {\n        invalidComponent.focus()\n      } else {\n        nestedFormElements.value\n          .forEach(item => isVaForm(item) && item.focusInvalid())\n      }\n    }\n\n    // validation for every nested child\n    const validate = () => { // NOTE: temporarily synchronous validation\n      const formValid = nestedFormElements.value\n        .filter(({ validate }) => validate)\n        .map((child) => child.validate()) // more readable than with 'forEach'\n        .every((isValid) => isValid)\n\n      emit('validation', formValid)\n\n      return formValid\n    }\n\n    const publicMethods: Form = {\n      reset,\n      resetValidation,\n      focus,\n      focusInvalid,\n      validate,\n    }\n\n    onMounted(() => {\n      parentFormProvider()?.onChildMounted?.(publicMethods)\n\n      if (props.autofocus) { nextTick(focus) }\n    })\n\n    onUnmounted(() => {\n      parentFormProvider()?.onChildUnmounted?.(publicMethods)\n    })\n\n    return publicMethods\n  },\n\n  // we will use this while we have 'withConfigTransport' and problem with 'expose' method in 'setup' func\n  methods: {\n    reset () { (this as any).form?.reset() },\n    resetValidation () { (this as any).form?.resetValidation() },\n    focus () { (this as any).form?.focus() },\n    focusInvalid () { (this as any).form?.focusInvalid() },\n    validate () { (this as any).form?.validate() },\n  },\n})\n</script>\n\n<style lang='scss'>\n.va-form {\n  font-family: var(--va-font-family);\n}\n</style>\n","<template>\n  <component\n    ref=\"form\"\n    class=\"va-form\"\n    :is=\"tag\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  PropType,\n  ref,\n  Ref,\n  onMounted,\n  onUnmounted,\n  nextTick,\n  provide,\n  inject,\n} from 'vue'\n\nimport { FormServiceKey, FormChild, Form } from './consts'\n\nconst isVaForm = (value: any): value is Form => !!value.focusInvalid\n\nexport default defineComponent({\n  name: 'VaForm',\n  emits: ['validation'],\n  props: {\n    autofocus: { type: Boolean as PropType<boolean>, default: false },\n    tag: { type: String as PropType<string>, default: 'div' },\n  },\n\n  setup (props, { emit }) {\n    const nestedFormElements: Ref<(FormChild | Form)[]> = ref([])\n\n    const parentFormProvider = () => inject(FormServiceKey, undefined)\n\n    provide(FormServiceKey, {\n      onChildMounted: (child: FormChild | Form) => childMountedHandler(child),\n      onChildUnmounted: (removableChild: FormChild | Form) => childUnmountedHandler(removableChild),\n    })\n\n    const childMountedHandler = (child: FormChild | Form) => {\n      nestedFormElements.value.push(child)\n    }\n\n    const childUnmountedHandler = (removableChild: FormChild | Form) => {\n      nestedFormElements.value = nestedFormElements.value.filter(child => child !== removableChild)\n    }\n\n    /** @public */\n    const reset = () => {\n      nestedFormElements.value\n        .filter(({ reset }) => reset)\n        .forEach((item) => { item.reset() })\n    }\n\n    const resetValidation = () => {\n      nestedFormElements.value\n        .filter(({ resetValidation }) => resetValidation)\n        .forEach((item: any) => { item.resetValidation() })\n    }\n\n    const focus = () => { nestedFormElements.value.find(({ focus }) => focus)?.focus() }\n\n    const focusInvalid = () => {\n      const invalidComponent = nestedFormElements.value\n        .find((item) => !isVaForm(item) && item.hasError())\n\n      if (invalidComponent) {\n        invalidComponent.focus()\n      } else {\n        nestedFormElements.value\n          .forEach(item => isVaForm(item) && item.focusInvalid())\n      }\n    }\n\n    // validation for every nested child\n    const validate = () => { // NOTE: temporarily synchronous validation\n      const formValid = nestedFormElements.value\n        .filter(({ validate }) => validate)\n        .map((child) => child.validate()) // more readable than with 'forEach'\n        .every((isValid) => isValid)\n\n      emit('validation', formValid)\n\n      return formValid\n    }\n\n    const publicMethods: Form = {\n      reset,\n      resetValidation,\n      focus,\n      focusInvalid,\n      validate,\n    }\n\n    onMounted(() => {\n      parentFormProvider()?.onChildMounted?.(publicMethods)\n\n      if (props.autofocus) { nextTick(focus) }\n    })\n\n    onUnmounted(() => {\n      parentFormProvider()?.onChildUnmounted?.(publicMethods)\n    })\n\n    return publicMethods\n  },\n\n  // we will use this while we have 'withConfigTransport' and problem with 'expose' method in 'setup' func\n  methods: {\n    reset () { (this as any).form?.reset() },\n    resetValidation () { (this as any).form?.resetValidation() },\n    focus () { (this as any).form?.focus() },\n    focusInvalid () { (this as any).form?.focusInvalid() },\n    validate () { (this as any).form?.validate() },\n  },\n})\n</script>\n\n<style lang='scss'>\n.va-form {\n  font-family: var(--va-font-family);\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport VaForm from './VaForm.vue'\n\nexport default withConfigTransport(VaForm)\n"],"names":["isVaForm","value","focusInvalid","defineComponent","name","emits","props","autofocus","type","Boolean","default","tag","String","setup","emit","nestedFormElements","ref","parentFormProvider","inject","FormServiceKey","undefined","provide","onChildMounted","child","childMountedHandler","onChildUnmounted","removableChild","childUnmountedHandler","push","filter","focus","find","publicMethods","reset","forEach","item","resetValidation","invalidComponent","hasError","validate","formValid","map","every","isValid","onMounted","nextTick","onUnmounted","methods","this","form","_createBlock","_ctx","class","_renderSlot","withConfigTransport","VaForm"],"mappings":"8UAyBA,MAAMA,SAAYC,KAAgCA,EAAMC,aAExD,MAAeC,EAAgB,CAC7BC,KAAM,SACNC,MAAO,CAAC,cACRC,MAAO,CACLC,UAAW,CAAEC,KAAMC,QAA8BC,SAAS,GAC1DC,IAAK,CAAEH,KAAMI,OAA4BF,QAAS,QAGpDG,MAAOP,GAAOQ,KAAEA,IACd,MAAMC,EAAgDC,EAAI,IAEpDC,mBAAqB,IAAMC,EAAOC,OAAgBC,GAExDC,EAAQF,EAAgB,CACtBG,eAAiBC,GAA4BC,oBAAoBD,GACjEE,iBAAmBC,GAAqCC,sBAAsBD,KAGhF,MAAMF,oBAAuBD,IAC3BR,EAAmBd,MAAM2B,KAAKL,IAG1BI,sBAAyBD,IAC7BX,EAAmBd,MAAQc,EAAmBd,MAAM4B,QAAON,GAASA,IAAUG,KAgB1EI,MAAQ,qBAAQf,EAAmBd,MAAM8B,MAAK,EAAGD,MAAAA,KAAYA,oBAAQA,SA0BrEE,EAAsB,CAC1BC,MAvCY,KACZlB,EAAmBd,MAChB4B,QAAO,EAAGI,MAAAA,KAAYA,IACtBC,SAASC,IAAWA,EAAKF,YAqC5BG,gBAlCsB,KACtBrB,EAAmBd,MAChB4B,QAAO,EAAGO,gBAAAA,KAAsBA,IAChCF,SAASC,IAAgBA,EAAKC,sBAgCjCN,MAAAA,MACA5B,aA5BmB,KACnB,MAAMmC,EAAmBtB,EAAmBd,MACzC8B,MAAMI,IAAUnC,SAASmC,IAASA,EAAKG,aAEtCD,EACFA,EAAiBP,QAEjBf,EAAmBd,MAChBiC,SAAQC,GAAQnC,SAASmC,IAASA,EAAKjC,kBAqB5CqC,SAhBe,KACf,MAAMC,EAAYzB,EAAmBd,MAClC4B,QAAO,EAAGU,SAAAA,KAAeA,IACzBE,KAAKlB,GAAUA,EAAMgB,aACrBG,OAAOC,GAAYA,IAItB,OAFA7B,EAAK,aAAc0B,GAEZA,IAqBT,OAVAI,GAAU,iCACR3B,2CAAsBK,sCAAiBU,GAEnC1B,EAAMC,WAAasC,EAASf,UAGlCgB,GAAY,iCACV7B,2CAAsBQ,wCAAmBO,MAGpCA,GAITe,QAAS,CACPd,wBAAYe,KAAaC,qBAAMhB,SAC/BG,kCAAsBY,KAAaC,qBAAMb,mBACzCN,wBAAYkB,KAAaC,qBAAMnB,SAC/B5B,+BAAmB8C,KAAaC,qBAAM/C,gBACtCqC,2BAAeS,KAAaC,qBAAMV,gECtHpCW,IAGOC,QAFLnC,IAAI,OACJoC,MAAM,uBAGN,KAAAC,iFCHJ,MAAeC,EAAoBC"}