{"version":3,"file":"index51.js","sources":["../../src/components/va-infinite-scroll/VaInfiniteScroll.vue","../../src/components/va-infinite-scroll/hooks/useScroll.ts","../../src/components/va-infinite-scroll/VaInfiniteScroll.vue?vue&type=template&id=b399cd12&lang.js","../../src/components/va-infinite-scroll/index.ts"],"sourcesContent":["<template>\n  <component\n    :is=\"$props.tag\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    ref=\"element\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n      ref=\"spinnerSlotContainer\"\n    >\n      <slot\n        name=\"loading\"\n        v-if=\"!$props.disabled\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport debounce from 'lodash/debounce.js'\nimport { computed, defineComponent, PropType, ref, watch } from 'vue'\nimport { sleep } from '../../services/utils'\nimport { useColor } from '../../composables/useColor'\nimport { useScroll } from './hooks/useScroll'\nimport { VaProgressCircle } from '../va-progress-circle'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: String as PropType<string | Element>, default: null },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = ref<HTMLElement>()\n    const spinnerSlotContainer = ref<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { computeColor } = useColor(props)\n\n    const spinnerColor = computed(() => {\n      return error.value ? computeColor('danger') : computeColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n","import { Ref, onMounted, onBeforeUnmount } from 'vue'\n\ninterface ScrollTargetProps {\n  scrollTarget: Element | string;\n  disabled: boolean;\n  reverse: boolean;\n}\n\nexport const useScroll = (\n  props: ScrollTargetProps,\n  element: Ref<HTMLElement | undefined>,\n  handler: Ref<any>,\n) => {\n  const addScrollListener = () => {\n    element.value?.addEventListener(\n      'scroll',\n      handler.value,\n      { passive: true },\n    )\n  }\n\n  const removeScrollListener = () => {\n    element.value?.removeEventListener(\n      'scroll',\n      handler.value,\n    )\n  }\n\n  onMounted(() => {\n    if (!element.value) { return }\n\n    element.value.style.overflowY = 'scroll'\n\n    if (props.reverse) {\n      element.value.scrollTop = element.value.scrollHeight\n    }\n\n    addScrollListener()\n  })\n\n  onBeforeUnmount(removeScrollListener)\n\n  return {\n    addScrollListener,\n    removeScrollListener,\n  }\n}\n","<template>\n  <component\n    :is=\"$props.tag\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    ref=\"element\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n      ref=\"spinnerSlotContainer\"\n    >\n      <slot\n        name=\"loading\"\n        v-if=\"!$props.disabled\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport debounce from 'lodash/debounce.js'\nimport { computed, defineComponent, PropType, ref, watch } from 'vue'\nimport { sleep } from '../../services/utils'\nimport { useColor } from '../../composables/useColor'\nimport { useScroll } from './hooks/useScroll'\nimport { VaProgressCircle } from '../va-progress-circle'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: String as PropType<string | Element>, default: null },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = ref<HTMLElement>()\n    const spinnerSlotContainer = ref<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { computeColor } = useColor(props)\n\n    const spinnerColor = computed(() => {\n      return error.value ? computeColor('danger') : computeColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n","import withConfigTransport from '../../services/config-transport/withConfigTransport'\nimport VaInfiniteScroll from './VaInfiniteScroll.vue'\n\nexport default withConfigTransport(VaInfiniteScroll)\n"],"names":["defineComponent","name","components","VaProgressCircle","props","load","type","Function","required","offset","Number","default","reverse","Boolean","disabled","scrollTarget","String","debounce","tag","emits","setup","emit","element","ref","spinnerSlotContainer","fetching","error","forcedScrolling","debouncedLoad","notScrolledContentBeforeLoad","prevScrollTop","scrollTargetElement","computed","target","document","querySelector","value","parentElement","body","addScrollListener","removeScrollListener","handler","addEventListener","passive","removeEventListener","onMounted","style","overflowY","scrollTop","scrollHeight","onBeforeUnmount","useScroll","computeColor","useColor","spinnerColor","spinnerHeight","offsetHeight","computedOffset","stop","resume","onLoad","clientHeight","scrollDelta","then","finishLoading","catch","onError","forceSetScrollTopToTarget","updateTargetElementScrollTop","isScrolledUp","isSpinnerHidden","stopErrorDisplay","sleep","watch","immediate","class","_createBlock","_ctx","_renderSlot","_createElementVNode","_hoisted_1","_createVNode","size","thickness","color","indeterminate","withConfigTransport","VaInfiniteScroll"],"mappings":"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"}